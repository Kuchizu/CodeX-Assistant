name: Check Linked Issue

on:
  workflow_call:
    inputs:
      mode:
        description: 'Modes: strict, draft or comment'
        required: false
        default: 'comment'
        type: string
    secrets:
      PR_DRAFT_TOKEN:
        description: 'Token with permissions to modify pull requests'
        required: true

jobs:
  check-linked-issue:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      contents: read
    
    steps:
      - name: Check linked issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_DRAFT_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('This workflow must be triggered by a pull_request event.');
              return;
            }

            const mode = ('${{ inputs.mode }}' || 'comment').trim().toLowerCase();
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = pr.number;

            async function addComment(body) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body,
              });
            }

            async function closePr() {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: prNumber,
                state: 'closed',
              });
            }

            async function convertToDraft() {
              await github.graphql(
                `
                  mutation ConvertToDraft($id: ID!) {
                    convertPullRequestToDraft(input: { pullRequestId: $id }) {
                      pullRequest {
                        isDraft
                      }
                    }
                  }
                `,
                { id: pr.node_id }
              );
            }

            async function reopenPr() {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: prNumber,
                state: 'open',
              });
            }

            async function markReadyForReview() {
              await github.graphql(
                `
                  mutation MarkReady($id: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) {
                      pullRequest {
                        isDraft
                      }
                    }
                  }
                `,
                { id: pr.node_id }
              );
            }

            const COMMENT_MARKER = '<!-- check-linked-issue-bot -->';

            async function findBotComment() {
              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
              });
              return comments.data.find(c => c.body && c.body.includes(COMMENT_MARKER));
            }

            const prData = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });

            const body = prData.data.body || '';

            // Get closing issues
            const result = await github.graphql(
              `
                query($owner: String!, $repo: String!, $number: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $number) {
                      closingIssuesReferences(first: 10) {
                        nodes {
                          number
                          state
                        }
                      }
                    }
                  }
                }
              `,
              {
                owner,
                repo,
                number: prNumber,
              }
            );

            const closingIssues = result.repository.pullRequest.closingIssuesReferences.nodes;

            // Extract issue numbers
            const issuePattern = /#(\d+)/g;
            const mentionedIssues = [];
            let match;
            const seenNumbers = new Set();

            while ((match = issuePattern.exec(body)) !== null) {
              const issueNum = parseInt(match[1], 10);
              if (!seenNumbers.has(issueNum)) {
                mentionedIssues.push(issueNum);
                seenNumbers.add(issueNum);
              }
            }

            const allIssueNumbers = new Set([
              ...closingIssues.map(i => i.number),
              ...mentionedIssues
            ]);

            const issueStatuses = {};
            for (const issueNum of allIssueNumbers) {
              try {
                const response = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number: issueNum,
                });

                // Check if this is an issue
                if (response.data.pull_request) {
                  issueStatuses[issueNum] = 'PULL_REQUEST';
                } else {
                  issueStatuses[issueNum] = response.data.state;
                }
              } catch (error) {
                issueStatuses[issueNum] = 'NOT_FOUND';
              }
            }

            const openIssueNums = Object.entries(issueStatuses)
              .filter(([_, state]) => state === 'open')
              .map(([num, _]) => parseInt(num, 10));

            const closedIssueNums = Object.entries(issueStatuses)
              .filter(([_, state]) => state === 'closed')
              .map(([num, _]) => parseInt(num, 10));

            const notFoundIssueNums = Object.entries(issueStatuses)
              .filter(([_, state]) => state === 'NOT_FOUND')
              .map(([num, _]) => parseInt(num, 10));

            const prNums = Object.entries(issueStatuses)
              .filter(([_, state]) => state === 'PULL_REQUEST')
              .map(([num, _]) => parseInt(num, 10));

            // At least one open issue?
            if (openIssueNums.length > 0) {
              // Check if we need to reopen/unmark draft
              const botComment = await findBotComment();
              if (botComment) {
                if (pr.state === 'closed' && mode === 'strict') {
                  await reopenPr();
                  await addComment(`${COMMENT_MARKER}\n### PR Reopened\n\nLinked issue found. This PR has been automatically reopened.`);
                } else if (pr.draft && mode === 'draft') {
                  await markReadyForReview();
                  await addComment(`${COMMENT_MARKER}\n### PR Ready for Review\n\nLinked issue found. This PR has been automatically marked as ready for review.`);
                }
              }
              return;
            }

            let message = `${COMMENT_MARKER}\n### Linked Issue Required\n\n`;
            message += `This pull request does not reference any open issue.\n\n`;

            if (closedIssueNums.length > 0 || prNums.length > 0 || notFoundIssueNums.length > 0) {
              message += `**References found:**\n`;
              if (closedIssueNums.length > 0) {
                message += `- Closed issues: ${closedIssueNums.map(n => `#${n}`).join(', ')}\n`;
              }
              if (prNums.length > 0) {
                message += `- Pull requests (not issues): ${prNums.map(n => `#${n}`).join(', ')}\n`;
              }
              if (notFoundIssueNums.length > 0) {
                message += `- Not found: ${notFoundIssueNums.map(n => `#${n}`).join(', ')}\n`;
              }
              message += `\n`;
            }

            message += `**Why this matters:**\n`;
            message += `Linking PRs to issues helps track progress, provides context for reviewers, and automatically closes issues when the PR is merged.\n\n`;
            message += `**How to link an issue:**\n`;
            message += `https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/linking-a-pull-request-to-an-issue\n\n`;

            if (mode === 'strict') {
              message += `**Action taken:** This PR has been closed. Please reopen it after linking to an open issue.`;
            } else if (mode === 'draft') {
              message += `**Action taken:** This PR has been converted to draft. Please link an open issue and mark it as ready for review when complete.`;
            } else {
              message += `Please update this PR to reference an open issue.`;
            }

            await addComment(message);

            if (mode === 'strict') {
              await closePr();
              return;
            }

            if (mode === 'draft') {
              if (!pr.draft) {
                await convertToDraft();
              }
              return;
            }
